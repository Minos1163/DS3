#!/usr/bin/env python3
"""
Auto-fix whitespace, blank lines and normalize top-level imports.

Usage: python scripts/auto_fix_whitespace_and_imports.py

This will modify .py files in the repository (excluding common non-source dirs)
and create a .bak backup of each file before writing changes.
"""
import ast
import os
import re
from typing import List, Tuple

ROOT_EXCLUDE = {'.venv', 'venv', '__pycache__', '.git', 'logs', 'data', 'docs', 'run'}


def should_skip(path: str) -> bool:
    parts = path.replace('\\', '/').split('/')
    return any(p in ROOT_EXCLUDE for p in parts)


def collect_top_level_imports(source: str) -> Tuple[List[Tuple[int, int]], List[str]]:
    """Return list of (lineno, end_lineno) for top-level Import/ImportFrom and their text lines."""
    tree = ast.parse(source)
    imports_pos: List[Tuple[int, int]] = []
    for node in tree.body:
        if isinstance(node, (ast.Import, ast.ImportFrom)):
            # ast nodes in py3.8+ have end_lineno
            end = getattr(node, 'end_lineno', node.lineno)
            imports_pos.append((node.lineno, end))
    # extract text for each import
    lines = source.splitlines()
    imports_text: List[str] = []
    for s, e in imports_pos:
        # lineno is 1-based
        snippet = '\n'.join(lines[s - 1:e])
        imports_text.append(snippet)
    return imports_pos, imports_text


def move_top_level_imports(filename: str, text: str) -> str:
    # Find top-level import blocks (lineno ranges) and move them to after module docstring.
    try:
        imports_pos, imports_text = collect_top_level_imports(text)
    except Exception:
        return text

    if not imports_pos:
        return text

    lines = text.splitlines()

    # Determine docstring end line if present
    doc_end = 0
    try:
        tree = ast.parse(text)
        doc = ast.get_docstring(tree)
        if doc:
            # find first Expr node which is the docstring
            first = tree.body[0]
            doc_end = getattr(first, 'end_lineno', first.lineno)
    except Exception:
        doc_end = 0

    # Build a set of line indices to remove (1-based)
    remove_lines = set()
    for s, e in imports_pos:
        # only remove imports that are not already at the top region (after docstring)
        if s > doc_end + 5:  # heuristic: if import is far below top, move it
            for i in range(s, e + 1):
                remove_lines.add(i)

    if not remove_lines:
        return text

    # Collect import snippets (unique, preserve order)
    import_snippets = []
    seen = set()
    for s, e in imports_pos:
        if any(i in remove_lines for i in range(s, e + 1)):
            snippet = '\n'.join(lines[s - 1:e])
            if snippet not in seen:
                import_snippets.append(snippet)
                seen.add(snippet)

    # Remove the lines
    new_lines = [ln for idx, ln in enumerate(lines, start=1) if idx not in remove_lines]

    # Insert imports after docstring end (or at top)
    insert_at = doc_end
    # ensure we don't insert in the middle of a shebang
    if new_lines and new_lines[0].startswith('#!'):
        insert_at = 1

    # convert to 0-based index for list insertion
    insert_idx = insert_at
    # ensure a blank line after imports
    snippet_block = '\n\n'.join(import_snippets).strip()
    if snippet_block:
        snippet_block_lines = snippet_block.splitlines()
        # Insert snippet and a blank line after
        new_lines[insert_idx:insert_idx] = snippet_block_lines + ['']

    return '\n'.join(new_lines) + ("\n" if not text.endswith('\n') else '')


def normalize_blank_lines_and_trailing_whitespace(text: str) -> str:
    # Remove trailing whitespace
    lines = [ln.rstrip() for ln in text.splitlines()]

    # Remove lines that contain only spaces (they became empty strings)
    # Collapse sequences of 3+ blank lines into 2
    out: List[str] = []
    blank_run = 0
    for ln in lines:
        if ln == '':
            blank_run += 1
        else:
            if blank_run > 2:
                out.extend(['', ''])
            elif blank_run > 0:
                out.extend([''] * blank_run)
            blank_run = 0
            out.append(ln)
    if blank_run > 0:
        if blank_run > 2:
            out.extend(['', ''])
        else:
            out.extend([''] * blank_run)

    # Ensure two blank lines before top-level defs/classes
    final: List[str] = []
    for i, ln in enumerate(out):
        stripped = ln.lstrip()
        if stripped.startswith('def ') or stripped.startswith('class '):
            # count previous blank lines
            prev_blank = 0
            j = len(final) - 1
            while j >= 0 and final[j] == '':
                prev_blank += 1
                j -= 1
            while prev_blank < 2:
                final.append('')
                prev_blank += 1
        final.append(ln)

    return '\n'.join(final) + ('\n' if text.endswith('\n') else '')


def process_file(path: str) -> bool:
    with open(path, 'r', encoding='utf-8') as f:
        text = f.read()

    orig = text

    # Move top-level imports
    try:
        text = move_top_level_imports(path, text)
    except Exception:
        pass

    # Normalize trailing whitespace and blank lines
    text = normalize_blank_lines_and_trailing_whitespace(text)

    if text != orig:
        # backup
        bak = path + '.bak'
        if not os.path.exists(bak):
            with open(bak, 'w', encoding='utf-8') as f:
                f.write(orig)
        with open(path, 'w', encoding='utf-8') as f:
            f.write(text)
        return True
    return False


def main():
    repo_root = os.getcwd()
    changed = []
    for root, dirs, files in os.walk(repo_root):
        # skip excluded top-level dirs
        rel = os.path.relpath(root, repo_root)
        if rel == '.':
            parts = []
        else:
            parts = rel.split(os.sep)
        if any(p in ROOT_EXCLUDE for p in parts):
            continue

        for fn in files:
            if not fn.endswith('.py'):
                continue
            path = os.path.join(root, fn)
            if should_skip(path):
                continue
            try:
                ok = process_file(path)
            except Exception as e:
                print(f"SKIP (error): {path}: {e}")
                continue
            if ok:
                changed.append(path)

    if changed:
        print('Modified files:')
        for p in changed:
            print(' -', p)
    else:
        print('No changes made.')


if __name__ == '__main__':
    main()
